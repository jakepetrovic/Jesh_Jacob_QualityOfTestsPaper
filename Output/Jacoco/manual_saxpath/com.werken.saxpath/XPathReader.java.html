<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>XPathReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">com.werken.saxpath</a> &gt; <span class="el_source">XPathReader.java</span></div><h1>XPathReader.java</h1><pre class="source lang-java linenums">/*
 * $Header: /cvsroot/saxpath/saxpath/src/java/main/com/werken/saxpath/XPathReader.java,v 1.23 2003/06/17 22:50:21 werken Exp $
 * $Revision: 1.23 $
 * $Date: 2003/06/17 22:50:21 $
 *
 * ====================================================================
 *
 * Copyright (C) 2000-2002 werken digital.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions, and the disclaimer that follows 
 *    these conditions in the documentation and/or other materials 
 *    provided with the distribution.
 *
 * 3. The name &quot;SAXPath&quot; must not be used to endorse or promote products
 *    derived from this software without prior written permission.  For
 *    written permission, please contact license@saxpath.org.
 * 
 * 4. Products derived from this software may not be called &quot;SAXPath&quot;, nor
 *    may &quot;SAXPath&quot; appear in their name, without prior written permission
 *    from the SAXPath Project Management (pm@saxpath.org).
 * 
 * In addition, we request (but do not require) that you include in the 
 * end-user documentation provided with the redistribution and/or in the 
 * software itself an acknowledgement equivalent to the following:
 *     &quot;This product includes software developed by the
 *      SAXPath Project (http://www.saxpath.org/).&quot;
 * Alternatively, the acknowledgment may be graphical using the logos 
 * available at http://www.saxpath.org/
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE SAXPath AUTHORS OR THE PROJECT
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * ====================================================================
 * This software consists of voluntary contributions made by many 
 * individuals on behalf of the SAXPath Project and was originally 
 * created by bob mcwhirter &lt;bob@werken.com&gt; and 
 * James Strachan &lt;jstrachan@apache.org&gt;.  For more information on the 
 * SAXPath Project, please see &lt;http://www.saxpath.org/&gt;.
 * 
 * $Id: XPathReader.java,v 1.23 2003/06/17 22:50:21 werken Exp $
 */

package com.werken.saxpath;

import org.saxpath.XPathHandler;
import org.saxpath.Axis;
import org.saxpath.Operator;
import org.saxpath.SAXPathException;
import org.saxpath.XPathSyntaxException;

import java.util.LinkedList;

/** Implementation of SAXPath's &lt;code&gt;XPathReader&lt;/code&gt; which
 *  generates callbacks to an &lt;code&gt;XPathHandler&lt;/code&gt;.
 *
 *  @author bob mcwhirter (bob@werken.com)
 */
public class XPathReader implements org.saxpath.XPathReader, TokenTypes
{
    private LinkedList tokens;
    private XPathLexer lexer; 

    private XPathHandler handler;

    public XPathReader()
<span class="fc" id="L85">    {</span>
<span class="fc" id="L86">        setXPathHandler( DefaultXPathHandler.getInstance() ); </span>
<span class="fc" id="L87">    }</span>

    public void setXPathHandler(XPathHandler handler)
    {
<span class="fc" id="L91">        this.handler = handler;</span>
<span class="fc" id="L92">    }</span>

    public XPathHandler getXPathHandler()
    {
<span class="fc" id="L96">        return this.handler;</span>
    }

    public void parse(String xpath) throws SAXPathException
    {
<span class="fc" id="L101">        setUpParse( xpath );</span>

<span class="fc" id="L103">        getXPathHandler().startXPath();</span>

<span class="fc" id="L105">        expr();</span>

<span class="fc" id="L107">        getXPathHandler().endXPath();</span>

<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if ( LA(1) != EOF )</span>
        {
<span class="nc" id="L111">            throwUnexpected();</span>
        }

<span class="fc" id="L114">        lexer  = null;</span>
<span class="fc" id="L115">        tokens = null;</span>
<span class="fc" id="L116">    }</span>

    void setUpParse(String xpath) 
    {
<span class="fc" id="L120">        this.tokens = new LinkedList();</span>
<span class="fc" id="L121">        this.lexer = new XPathLexer( xpath );</span>
<span class="fc" id="L122">    }</span>

    void pathExpr() throws SAXPathException
    {
<span class="fc" id="L126">        getXPathHandler().startPathExpr();</span>

<span class="pc bpc" id="L128" title="1 of 5 branches missed.">        switch ( LA(1) )</span>
        {
            case INTEGER:
            case DOUBLE:
            case LITERAL:
            case LEFT_PAREN:
            case DOLLAR:
            {
<span class="fc" id="L136">                filterExpr();</span>

<span class="pc bpc" id="L138" title="2 of 4 branches missed.">                if ( LA(1) == SLASH || LA(1) == DOUBLE_SLASH )</span>
                {
<span class="nc" id="L140">                    locationPath( false );</span>
                }

                break;
            }
            case IDENTIFIER:
            {
                // if ( ( ( LA(2) == LEFT_PAREN )
                  //      &amp;&amp;
                  //      ( ! isNodeTypeName( LT(1) ) ) ) )

<span class="pc bpc" id="L151" title="6 of 8 branches missed.">                if ( ( LA(2) == LEFT_PAREN</span>
                     &amp;&amp;
                       ! isNodeTypeName( LT(1) ) )
                     ||
                    ( LA(2) == COLON
                      &amp;&amp;
                      LA(4) == LEFT_PAREN) ) 
                {
<span class="nc" id="L159">                    filterExpr();</span>
                    
<span class="nc bnc" id="L161" title="All 4 branches missed.">                    if ( LA(1) == SLASH || LA(1) == DOUBLE_SLASH)</span>
                    {
<span class="nc" id="L163">                        locationPath( false );</span>
                    }

                    break;
                }
                else
                {
<span class="fc" id="L170">                    locationPath( false );</span>
<span class="fc" id="L171">                    break;</span>
                }
            }
            case DOT:
            case DOT_DOT:
            case STAR:
            case AT:
            {
<span class="fc" id="L179">                locationPath( false );</span>
<span class="fc" id="L180">                break;</span>
            }
            case SLASH:
            case DOUBLE_SLASH:
            {
<span class="fc" id="L185">                locationPath( true );</span>
<span class="fc" id="L186">                break;</span>
            }
            default:
            {
                //throw new XPathSyntaxException( &quot;Unexpected '&quot; + LT(1).getTokenText() + &quot;'&quot; );
<span class="nc" id="L191">                throwUnexpected();</span>
            }
        }

<span class="fc" id="L195">        getXPathHandler().endPathExpr();</span>
<span class="fc" id="L196">    }</span>

    void numberDouble() throws SAXPathException
    {
<span class="nc" id="L200">        Token token = match( DOUBLE );</span>

<span class="nc" id="L202">        getXPathHandler().number( Double.parseDouble( token.getTokenText() ) );</span>
<span class="nc" id="L203">    }</span>

    void numberInteger() throws SAXPathException
    {
<span class="fc" id="L207">        Token token = match( INTEGER );</span>
            
<span class="fc" id="L209">        getXPathHandler().number( Integer.parseInt( token.getTokenText() ) );</span>
<span class="fc" id="L210">    }</span>

    void literal() throws SAXPathException
    {
<span class="fc" id="L214">        Token token = match( LITERAL );</span>

<span class="fc" id="L216">        getXPathHandler().literal( token.getTokenText() );</span>
<span class="fc" id="L217">    }</span>

    void functionCall() throws SAXPathException
    {
<span class="nc" id="L221">        String prefix       = null;</span>
<span class="nc" id="L222">        String functionName = null;</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">        if ( LA(2) == COLON )</span>
        {
<span class="nc" id="L226">            prefix = match( IDENTIFIER ).getTokenText();</span>
<span class="nc" id="L227">            match( COLON );</span>
        }
        else
        {
<span class="nc" id="L231">            prefix = &quot;&quot;;</span>
        }

<span class="nc" id="L234">        functionName = match( IDENTIFIER ).getTokenText();</span>

<span class="nc" id="L236">        getXPathHandler().startFunction( prefix,</span>
                                         functionName );

<span class="nc" id="L239">        match ( LEFT_PAREN );</span>

<span class="nc" id="L241">        arguments();</span>

<span class="nc" id="L243">        match ( RIGHT_PAREN );</span>

<span class="nc" id="L245">        getXPathHandler().endFunction();</span>
<span class="nc" id="L246">    }</span>

    void arguments() throws SAXPathException
    {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        while ( LA(1) != RIGHT_PAREN )</span>
        {
<span class="nc" id="L252">            expr();</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">            if ( LA(1) == COMMA )</span>
            {
<span class="nc" id="L256">                match( COMMA );</span>
            }
            else
            {
                break;
            }
        }
<span class="nc" id="L263">    }</span>

    void filterExpr() throws SAXPathException
    {

<span class="fc" id="L268">        getXPathHandler().startFilterExpr();</span>

<span class="pc bpc" id="L270" title="5 of 7 branches missed.">        switch ( LA(1) )</span>
        {
            case INTEGER:
            {
<span class="fc" id="L274">                numberInteger();</span>
<span class="fc" id="L275">                break;</span>
            }
            case DOUBLE:
            {
<span class="nc" id="L279">                numberDouble();</span>
<span class="nc" id="L280">                break;</span>
            }
            case LITERAL:
            {
<span class="fc" id="L284">                literal();</span>
<span class="fc" id="L285">                break;</span>
            }
            case LEFT_PAREN:
            {
<span class="nc" id="L289">                match( LEFT_PAREN );</span>
<span class="nc" id="L290">                expr();</span>
<span class="nc" id="L291">                match( RIGHT_PAREN );</span>
<span class="nc" id="L292">                break;</span>
            }
            case IDENTIFIER:
            {
<span class="nc" id="L296">                functionCall();</span>
<span class="nc" id="L297">                break;</span>
            }
            case DOLLAR:
            {
<span class="nc" id="L301">                variableReference();</span>
                break;
            }
        }

<span class="fc" id="L306">        predicates();</span>

<span class="fc" id="L308">        getXPathHandler().endFilterExpr();</span>
<span class="fc" id="L309">    }</span>

    void variableReference() throws SAXPathException
    {
<span class="nc" id="L313">        match( DOLLAR );</span>

<span class="nc" id="L315">        String prefix       = null;</span>
<span class="nc" id="L316">        String variableName = null;</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if ( LA(2) == COLON )</span>
        {
<span class="nc" id="L320">            prefix = match( IDENTIFIER ).getTokenText();</span>
<span class="nc" id="L321">            match( COLON );</span>
        }
        else
        {
<span class="nc" id="L325">            prefix = &quot;&quot;;</span>
        }

<span class="nc" id="L328">        variableName = match( IDENTIFIER ).getTokenText();</span>

<span class="nc" id="L330">        getXPathHandler().variableReference( prefix,</span>
                                             variableName );
<span class="nc" id="L332">    }</span>

    void locationPath(boolean isAbsolute) throws SAXPathException
    {
<span class="pc bpc" id="L336" title="1 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case SLASH:
            case DOUBLE_SLASH:
            {
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                if ( isAbsolute )</span>
                {
<span class="fc" id="L343">                    absoluteLocationPath();</span>
                }
                else
                {
<span class="nc" id="L347">                    relativeLocationPath();</span>
                }
<span class="nc" id="L349">                break;</span>
            }
            case AT:
            case IDENTIFIER:
            case DOT:
            case DOT_DOT:
            case STAR:
            {
<span class="fc" id="L357">                relativeLocationPath();</span>
<span class="fc" id="L358">                break;</span>
            }
            default:
            {
<span class="nc" id="L362">                throwUnexpected();</span>
                break;
            }
        }
<span class="fc" id="L366">    }</span>

    void absoluteLocationPath() throws SAXPathException
    {
<span class="fc" id="L370">        getXPathHandler().startAbsoluteLocationPath();</span>

<span class="pc bpc" id="L372" title="1 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case SLASH:
            {
<span class="fc" id="L376">                match( SLASH );</span>

<span class="pc bpc" id="L378" title="2 of 3 branches missed.">                switch ( LA(1) )</span>
                {

                    case DOT:
                    case DOT_DOT:
                    case AT:
                    case IDENTIFIER:
                    case STAR:
                    {
<span class="fc" id="L387">                        steps();</span>
<span class="fc" id="L388">                        break;</span>
                    }
                    case EOF:
                    {
<span class="nc" id="L392">                        return;</span>
                    }
                }
<span class="fc" id="L395">                break;</span>
            }
            case DOUBLE_SLASH:
            {
<span class="fc" id="L399">                getXPathHandler().startAllNodeStep( Axis.DESCENDANT_OR_SELF );</span>
<span class="fc" id="L400">                getXPathHandler().endAllNodeStep();</span>

<span class="fc" id="L402">                match( DOUBLE_SLASH );</span>

<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                switch ( LA(1) )</span>
                {

                    case DOT:
                    case DOT_DOT:
                    case AT:
                    case IDENTIFIER:
                    case STAR:
                    {
<span class="fc" id="L413">                        steps();</span>
                        break;
                    }
                }
                break;
            }
        }
        
<span class="fc" id="L421">        getXPathHandler().endAbsoluteLocationPath();</span>
<span class="fc" id="L422">    }</span>

    void relativeLocationPath() throws SAXPathException
    {
<span class="fc" id="L426">        getXPathHandler().startRelativeLocationPath();</span>

<span class="pc bpc" id="L428" title="2 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case SLASH:
            {
<span class="nc" id="L432">                match( SLASH );</span>
<span class="nc" id="L433">                break;</span>
            }
            case DOUBLE_SLASH:
            {
<span class="nc" id="L437">                getXPathHandler().startAllNodeStep( Axis.DESCENDANT_OR_SELF );</span>
<span class="nc" id="L438">                getXPathHandler().endAllNodeStep();</span>

<span class="nc" id="L440">                match( DOUBLE_SLASH );</span>

                break;
            }
        }

<span class="fc" id="L446">        steps();</span>

<span class="fc" id="L448">        getXPathHandler().endRelativeLocationPath();</span>
<span class="fc" id="L449">    }</span>

    void steps() throws SAXPathException
    {
<span class="pc bpc" id="L453" title="2 of 3 branches missed.">        switch ( LA(1) )</span>
        {

            case DOT:
            case DOT_DOT:
            case AT:
            case IDENTIFIER:
            case STAR:
            {
<span class="fc" id="L462">                step( true );</span>
<span class="fc" id="L463">                break;</span>
            }
            case EOF:
            {
<span class="nc" id="L467">                return;</span>
            }
            default:
            {
<span class="nc" id="L471">                throwSyntaxException( &quot;Expected one of '.', '..', '@', '*', &lt;QName&gt;&quot; );</span>
                //throw new XPathSyntaxException( &quot;Expected one of '.', '..', '@', '*', &lt;qname&gt;&quot; );
            }
        }

        do
        {
<span class="pc bpc" id="L478" title="1 of 4 branches missed.">            if ( ( LA(1) == SLASH)</span>
                 ||
                 ( LA(1) == DOUBLE_SLASH ) )
            {
<span class="pc bpc" id="L482" title="2 of 3 branches missed.">                switch ( LA(1) )</span>
                {
                    case SLASH:
                    {
<span class="fc" id="L486">                        match( SLASH );</span>
<span class="fc" id="L487">                        break;</span>
                    }
                    case DOUBLE_SLASH:
                    {
<span class="nc" id="L491">                        getXPathHandler().startAllNodeStep( Axis.DESCENDANT_OR_SELF );</span>
<span class="nc" id="L492">                        getXPathHandler().endAllNodeStep();</span>

<span class="nc" id="L494">                        match( DOUBLE_SLASH );</span>
<span class="fc" id="L495">                        break;</span>
                    }
                }
            }
            else
            {
<span class="fc" id="L501">                return;</span>
            }
            
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">            switch ( LA(1) )</span>
            {
                case DOT:
                case DOT_DOT:
                case AT:
                case IDENTIFIER:
                case STAR:
                {
<span class="fc" id="L512">                    step( false );</span>
<span class="fc" id="L513">                    break;</span>
                }
                default:
                {
<span class="nc" id="L517">                    throwSyntaxException( &quot;Expected one of '.', '..', '@', '*', &lt;QName&gt;&quot; );</span>
                    // throw new XPathSyntaxException( &quot;Expected one of '.', '..', '@', '*', &lt;qname&gt;&quot; );
                }
            }

<span class="nc" id="L522">        } while ( true );</span>
    }

    void step(boolean first) throws SAXPathException
    {
<span class="fc" id="L527">        int axis = 0;</span>

<span class="pc bpc" id="L529" title="1 of 5 branches missed.">        switch ( LA(1) )</span>
        {
            case DOT:
            case DOT_DOT:
            {
<span class="fc" id="L534">                abbrStep();</span>
<span class="fc" id="L535">                return;</span>
            }
            case AT:
            {
<span class="fc" id="L539">                axis = axisSpecifier();</span>
<span class="fc" id="L540">                break;</span>
            }
            case IDENTIFIER:
            {
<span class="fc bfc" id="L544" title="All 2 branches covered.">                if ( LA(2) == DOUBLE_COLON )</span>
                {
<span class="fc" id="L546">                    axis = axisSpecifier();</span>
                }
                else
                {
<span class="fc" id="L550">                    axis = Axis.CHILD;</span>
                }
<span class="fc" id="L552">                break;</span>
            }
            case STAR:
            {
<span class="fc" id="L556">                axis = Axis.CHILD;</span>
                break;
            }
        }

<span class="fc" id="L561">        nodeTest( axis );</span>
<span class="fc" id="L562">    }</span>

    int axisSpecifier() throws SAXPathException
    {
<span class="fc" id="L566">        int axis = 0;</span>

<span class="pc bpc" id="L568" title="1 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case AT:
            {
<span class="fc" id="L572">                match( AT );</span>
<span class="fc" id="L573">                axis = Axis.ATTRIBUTE;</span>
<span class="fc" id="L574">                break;</span>
            }
            case IDENTIFIER:
            {
<span class="fc" id="L578">                Token token = LT( 1 );</span>

<span class="fc" id="L580">                axis = Axis.lookup( token.getTokenText() );</span>

<span class="pc bpc" id="L582" title="1 of 2 branches missed.">                if ( axis == Axis.INVALID_AXIS )</span>
                {
<span class="nc" id="L584">                    throwInvalidAxis( token.getTokenText() );</span>
                }

<span class="fc" id="L587">                match( IDENTIFIER );</span>
<span class="fc" id="L588">                match( DOUBLE_COLON );</span>

<span class="fc" id="L590">                break;</span>
            }
        }

<span class="fc" id="L594">        return axis;</span>
    }

    void nodeTest(int axis) throws SAXPathException
    {
<span class="pc bpc" id="L599" title="1 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case IDENTIFIER:
            {
<span class="fc bfc" id="L603" title="All 2 branches covered.">                switch ( LA(2) )</span>
                {
                    case LEFT_PAREN:
                    {
<span class="fc" id="L607">                        nodeTypeTest( axis );</span>
<span class="fc" id="L608">                        break;</span>
                    }
                    default:
                    {
<span class="fc" id="L612">                        nameTest( axis );</span>
<span class="fc" id="L613">                        break;</span>
                    }
                }
                break;
            }
            case STAR:
            {
<span class="fc" id="L620">                nameTest( axis );</span>
                break;
            }
        }
<span class="fc" id="L624">    }</span>

    void nodeTypeTest(int axis) throws SAXPathException
    {
<span class="fc" id="L628">        Token  nodeTypeToken = match( IDENTIFIER );</span>
<span class="fc" id="L629">        String nodeType      = nodeTypeToken.getTokenText();</span>

<span class="fc" id="L631">        match( LEFT_PAREN );</span>

<span class="fc bfc" id="L633" title="All 2 branches covered.">        if ( &quot;processing-instruction&quot;.equals( nodeType ) )</span>
        {
<span class="fc" id="L635">            String piName = &quot;&quot;;</span>

<span class="fc bfc" id="L637" title="All 2 branches covered.">            if ( LA(1) == LITERAL )</span>
            {
<span class="fc" id="L639">                piName = match( LITERAL ).getTokenText();</span>
            }

<span class="fc" id="L642">            match( RIGHT_PAREN );</span>

<span class="fc" id="L644">            getXPathHandler().startProcessingInstructionNodeStep( axis,</span>
                                                                  piName );

<span class="fc" id="L647">            predicates();</span>

<span class="fc" id="L649">            getXPathHandler().endProcessingInstructionNodeStep();</span>
<span class="fc" id="L650">        }</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">        else if ( &quot;node&quot;.equals( nodeType ) )</span>
        {
<span class="fc" id="L653">            match( RIGHT_PAREN );</span>

<span class="fc" id="L655">            getXPathHandler().startAllNodeStep( axis );</span>

<span class="fc" id="L657">            predicates();</span>

<span class="fc" id="L659">            getXPathHandler().endAllNodeStep();</span>
        }
<span class="fc bfc" id="L661" title="All 2 branches covered.">        else if ( &quot;text&quot;.equals( nodeType ) )</span>
        {
<span class="fc" id="L663">            match( RIGHT_PAREN );</span>

<span class="fc" id="L665">            getXPathHandler().startTextNodeStep( axis );</span>

<span class="fc" id="L667">            predicates();</span>

<span class="fc" id="L669">            getXPathHandler().endTextNodeStep();</span>
        }
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        else if ( &quot;comment&quot;.equals( nodeType ) )</span>
        {
<span class="fc" id="L673">            match( RIGHT_PAREN );</span>

<span class="fc" id="L675">            getXPathHandler().startCommentNodeStep( axis );</span>

<span class="fc" id="L677">            predicates();</span>

<span class="fc" id="L679">            getXPathHandler().endCommentNodeStep();</span>
        }
        else
        {
<span class="nc" id="L683">            throwSyntaxException( &quot;Expected node-type&quot; );</span>
        }
<span class="fc" id="L685">    }</span>

    void nameTest(int axis) throws SAXPathException
    {
<span class="fc" id="L689">        String prefix    = null;</span>
<span class="fc" id="L690">        String localName = null;</span>

<span class="fc bfc" id="L692" title="All 2 branches covered.">        switch ( LA(2) )</span>
        {
            case COLON:
            {
<span class="fc bfc" id="L696" title="All 2 branches covered.">                switch ( LA(1) )</span>
                {
                    case IDENTIFIER:
                    {
<span class="fc" id="L700">                        prefix = match( IDENTIFIER ).getTokenText();</span>
<span class="fc" id="L701">                        match( COLON );</span>
                        break;
                    }
                }
                break;
            }
        }
        
<span class="pc bpc" id="L709" title="1 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case IDENTIFIER:
            {
<span class="fc" id="L713">                localName = match( IDENTIFIER ).getTokenText();</span>
<span class="fc" id="L714">                break;</span>
            }
            case STAR:
            {
<span class="fc" id="L718">                match( STAR );</span>
<span class="fc" id="L719">                localName = &quot;*&quot;;</span>
                break;
            }
        }

<span class="fc bfc" id="L724" title="All 2 branches covered.">        if ( prefix == null )</span>
        {
<span class="fc" id="L726">            prefix = &quot;&quot;;</span>
        }
        
<span class="fc" id="L729">        getXPathHandler().startNameStep( axis,</span>
                                         prefix,
                                         localName );

<span class="fc" id="L733">        predicates();</span>

<span class="fc" id="L735">        getXPathHandler().endNameStep();</span>
<span class="fc" id="L736">    }</span>

    void abbrStep() throws SAXPathException
    {
<span class="pc bpc" id="L740" title="2 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case DOT:
            {
<span class="fc" id="L744">                match( DOT );</span>
<span class="fc" id="L745">                getXPathHandler().startAllNodeStep( Axis.SELF );</span>
<span class="fc" id="L746">                predicates();</span>
<span class="fc" id="L747">                getXPathHandler().endAllNodeStep();</span>
<span class="fc" id="L748">                break;</span>
            }
            case DOT_DOT:
            {
<span class="nc" id="L752">                match( DOT_DOT );</span>
<span class="nc" id="L753">                getXPathHandler().startAllNodeStep( Axis.PARENT );</span>
<span class="nc" id="L754">                predicates();</span>
<span class="nc" id="L755">                getXPathHandler().endAllNodeStep();</span>
                break;
            }
        }
<span class="fc" id="L759">    }</span>

    void predicates() throws SAXPathException
    {
        while (true )
        {
<span class="fc bfc" id="L765" title="All 2 branches covered.">            if ( LA(1) == LEFT_BRACKET )</span>
            {
<span class="fc" id="L767">                predicate();</span>
            }
            else
            {
                break;
            }
        }
<span class="fc" id="L774">    }</span>
    
    void predicate() throws SAXPathException
    {
<span class="fc" id="L778">        getXPathHandler().startPredicate();</span>
        
<span class="fc" id="L780">        match( LEFT_BRACKET );</span>
        
<span class="fc" id="L782">        predicateExpr();</span>

<span class="fc" id="L784">        match( RIGHT_BRACKET );</span>

<span class="fc" id="L786">        getXPathHandler().endPredicate();</span>
<span class="fc" id="L787">    }</span>

    void predicateExpr() throws SAXPathException
    {
<span class="fc" id="L791">        expr();</span>
<span class="fc" id="L792">    }</span>

    void expr() throws SAXPathException
    {
<span class="fc" id="L796">        orExpr();</span>
<span class="fc" id="L797">    }</span>

    void orExpr() throws SAXPathException
    {
<span class="fc" id="L801">        getXPathHandler().startOrExpr();</span>
        
<span class="fc" id="L803">        andExpr();</span>

<span class="fc" id="L805">        boolean create = false;</span>

<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        switch ( LA(1) )</span>
        {
            case OR:
            {
<span class="nc" id="L811">                create = true;</span>
<span class="nc" id="L812">                match( OR );</span>
<span class="nc" id="L813">                orExpr();</span>
                break;
            }
        }

<span class="fc" id="L818">        getXPathHandler().endOrExpr( create );</span>
<span class="fc" id="L819">    }</span>

    void andExpr() throws SAXPathException
    {
<span class="fc" id="L823">        getXPathHandler().startAndExpr();</span>

<span class="fc" id="L825">        equalityExpr();</span>

<span class="fc" id="L827">        boolean create = false;</span>

<span class="fc bfc" id="L829" title="All 2 branches covered.">        switch ( LA(1) )</span>
        {
            case AND:
            {
<span class="fc" id="L833">                create = true;</span>
<span class="fc" id="L834">                match( AND );</span>
<span class="fc" id="L835">                andExpr();</span>
                break;
            }
        }

<span class="fc" id="L840">        getXPathHandler().endAndExpr( create );</span>
<span class="fc" id="L841">    }</span>

    void equalityExpr() throws SAXPathException
    {
<span class="fc" id="L845">        getXPathHandler().startEqualityExpr();</span>

<span class="fc" id="L847">        relationalExpr();</span>

<span class="fc" id="L849">        int operator = Operator.NO_OP;</span>

<span class="fc bfc" id="L851" title="All 3 branches covered.">        switch ( LA(1) )</span>
        {
            case EQUALS:
            {
<span class="fc" id="L855">                match( EQUALS );</span>
<span class="fc" id="L856">                equalityExpr();</span>
<span class="fc" id="L857">                operator = Operator.EQUALS;</span>
<span class="fc" id="L858">                break;</span>
            }
            case NOT_EQUALS:
            {
<span class="fc" id="L862">                match( NOT_EQUALS );</span>
<span class="fc" id="L863">                equalityExpr();</span>
<span class="fc" id="L864">                operator = Operator.NOT_EQUALS;</span>
                break;
            }
        }

<span class="fc" id="L869">        getXPathHandler().endEqualityExpr( operator );</span>
<span class="fc" id="L870">    }</span>

    void relationalExpr() throws SAXPathException
    {
<span class="fc" id="L874">        getXPathHandler().startRelationalExpr();</span>

<span class="fc" id="L876">        additiveExpr();</span>

<span class="fc" id="L878">        int operator = Operator.NO_OP;</span>

<span class="pc bpc" id="L880" title="4 of 5 branches missed.">        switch ( LA(1) )</span>
        {
            case LESS_THAN:
            {
<span class="nc" id="L884">                match( LESS_THAN );</span>
<span class="nc" id="L885">                relationalExpr();</span>
<span class="nc" id="L886">                operator = Operator.LESS_THAN;</span>
<span class="nc" id="L887">                break;</span>
            }
            case GREATER_THAN:
            {
<span class="nc" id="L891">                match( GREATER_THAN );</span>
<span class="nc" id="L892">                relationalExpr();</span>
<span class="nc" id="L893">                operator = Operator.GREATER_THAN;</span>
<span class="nc" id="L894">                break;</span>
            }
            case LESS_THAN_EQUALS:
            {
<span class="nc" id="L898">                match( LESS_THAN_EQUALS );</span>
<span class="nc" id="L899">                relationalExpr();</span>
<span class="nc" id="L900">                operator = Operator.LESS_THAN_EQUALS;</span>
<span class="nc" id="L901">                break;</span>
            }
            case GREATER_THAN_EQUALS:
            {
<span class="nc" id="L905">                match( GREATER_THAN_EQUALS );</span>
<span class="nc" id="L906">                relationalExpr();</span>
<span class="nc" id="L907">                operator = Operator.GREATER_THAN_EQUALS;</span>
                break;
            }
        }

<span class="fc" id="L912">        getXPathHandler().endRelationalExpr( operator );</span>
<span class="fc" id="L913">    }</span>

    void additiveExpr() throws SAXPathException
    {
<span class="fc" id="L917">        getXPathHandler().startAdditiveExpr();</span>

<span class="fc" id="L919">        multiplicativeExpr();</span>

<span class="fc" id="L921">        int operator = Operator.NO_OP;</span>

<span class="pc bpc" id="L923" title="2 of 3 branches missed.">        switch ( LA(1) )</span>
        {
            case PLUS:
            {
<span class="nc" id="L927">                match( PLUS );</span>
<span class="nc" id="L928">                operator = Operator.ADD;</span>
<span class="nc" id="L929">                additiveExpr();</span>
<span class="nc" id="L930">                break;</span>
            }
            case MINUS:
            {
<span class="nc" id="L934">                match( MINUS );</span>
<span class="nc" id="L935">                operator = Operator.SUBTRACT;</span>
<span class="nc" id="L936">                additiveExpr();</span>
                break;
            }
        }

<span class="fc" id="L941">        getXPathHandler().endAdditiveExpr( operator );</span>
<span class="fc" id="L942">    }</span>

    void multiplicativeExpr() throws SAXPathException
    {
<span class="fc" id="L946">        getXPathHandler().startMultiplicativeExpr();</span>

<span class="fc" id="L948">        unaryExpr();</span>

<span class="fc" id="L950">        int operator = Operator.NO_OP;</span>

<span class="pc bpc" id="L952" title="3 of 4 branches missed.">        switch ( LA(1) )</span>
        {
            case STAR:
            {
<span class="nc" id="L956">                match( STAR );</span>
<span class="nc" id="L957">                multiplicativeExpr();</span>
<span class="nc" id="L958">                operator = Operator.MULTIPLY;</span>
<span class="nc" id="L959">                break;                </span>
            }
            case DIV:
            {
<span class="nc" id="L963">                match( DIV );</span>
<span class="nc" id="L964">                multiplicativeExpr();</span>
<span class="nc" id="L965">                operator = Operator.DIV;</span>
<span class="nc" id="L966">                break;</span>
            }
            case MOD:
            {
<span class="nc" id="L970">                match( MOD );</span>
<span class="nc" id="L971">                multiplicativeExpr();</span>
<span class="nc" id="L972">                operator = Operator.MOD;</span>
                break;
            }
        }

<span class="fc" id="L977">        getXPathHandler().endMultiplicativeExpr( operator );</span>
<span class="fc" id="L978">    }</span>

    void unaryExpr() throws SAXPathException
    {
<span class="fc" id="L982">        getXPathHandler().startUnaryExpr();</span>

<span class="fc" id="L984">        int operator = Operator.NO_OP;</span>

<span class="pc bpc" id="L986" title="1 of 2 branches missed.">        switch ( LA(1) )</span>
        {
            case MINUS:
            {
<span class="nc" id="L990">                match( MINUS );</span>
<span class="nc" id="L991">                operator = Operator.NEGATIVE;</span>
<span class="nc" id="L992">                unaryExpr();</span>
<span class="nc" id="L993">                break;</span>
            }
            default:
            {
<span class="fc" id="L997">                unionExpr();</span>
                break;
            }
        }

<span class="fc" id="L1002">        getXPathHandler().endUnaryExpr( operator );</span>
<span class="fc" id="L1003">    }</span>

    void unionExpr() throws SAXPathException
    {
<span class="fc" id="L1007">        getXPathHandler().startUnionExpr();</span>

<span class="fc" id="L1009">        pathExpr();</span>

<span class="fc" id="L1011">        boolean create = false;</span>

<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">        switch ( LA(1) )</span>
        {
            case PIPE:
            {
<span class="nc" id="L1017">                match( PIPE );</span>
<span class="nc" id="L1018">                create = true;</span>
<span class="nc" id="L1019">                expr();</span>
                break;
            }
        }

<span class="fc" id="L1024">        getXPathHandler().endUnionExpr( create );</span>
<span class="fc" id="L1025">    }</span>

    Token match(int tokenType)
    {
<span class="fc" id="L1029">        LT(1);</span>

<span class="fc" id="L1031">        Token token = (Token) tokens.get( 0 );</span>

<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">        if ( token.getTokenType() == tokenType )</span>
        {
<span class="fc" id="L1035">            tokens.removeFirst();</span>
<span class="fc" id="L1036">            return token;</span>
        }

        // throw an exception

<span class="nc" id="L1041">        return null;</span>
    }

    int LA(int position)
    {
<span class="fc" id="L1046">        return LT(position).getTokenType();</span>
    }

    Token LT(int position)
    {
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if ( tokens.size() &lt;= ( position - 1 ) )</span>
        {
<span class="fc bfc" id="L1053" title="All 2 branches covered.">            for ( int i = 0 ; i &lt; position ; ++i )</span>
            {
<span class="fc" id="L1055">                tokens.add( lexer.nextToken() );</span>
            }
        }

<span class="fc" id="L1059">        return (Token) tokens.get( position - 1 );</span>
    }

    boolean isNodeTypeName(Token name)
    {
<span class="nc" id="L1064">        String text = name.getTokenText();</span>

<span class="nc bnc" id="L1066" title="All 8 branches missed.">        if ( &quot;node&quot;.equals( text )</span>
             ||
             &quot;comment&quot;.equals( text )
             ||
             &quot;text&quot;.equals( text )
             ||
             &quot;processing-instruction&quot;.equals( text ) )
        {
<span class="nc" id="L1074">            return true;</span>
        }

<span class="nc" id="L1077">        return false;</span>
    }

    void throwSyntaxException(String message) throws SAXPathException
    {
<span class="fc" id="L1082">        String xpath    = this.lexer.getXPath();</span>
<span class="fc" id="L1083">        int    position = LT(1).getTokenBegin();</span>

<span class="fc" id="L1085">        throw new XPathSyntaxException( xpath,</span>
                                        position,
                                        message );
    }

    void throwInvalidAxis(String invalidAxis) throws SAXPathException
    {
<span class="fc" id="L1092">        String xpath    = this.lexer.getXPath();</span>
<span class="fc" id="L1093">        int    position = LT(1).getTokenBegin();</span>

<span class="fc" id="L1095">        String message  = &quot;Expected valid axis name instead of [&quot; + invalidAxis + &quot;]&quot;;</span>

<span class="fc" id="L1097">        throw new XPathSyntaxException( xpath,</span>
                                        position,
                                        message );
    }

    void throwUnexpected() throws SAXPathException
    {
<span class="nc" id="L1104">        throwSyntaxException( &quot;Unexpected '&quot; + LT(1).getTokenText() + &quot;'&quot; );</span>
<span class="nc" id="L1105">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201405220205</span></div></body></html>