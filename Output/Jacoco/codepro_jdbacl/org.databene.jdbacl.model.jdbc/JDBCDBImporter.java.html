<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JDBCDBImporter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.databene.jdbacl.model.jdbc</a> &gt; <span class="el_source">JDBCDBImporter.java</span></div><h1>JDBCDBImporter.java</h1><pre class="source lang-java linenums">/*
 * (c) Copyright 2006-2011 by Volker Bergmann. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, is permitted under the terms of the
 * GNU General Public License.
 *
 * For redistributing this software or a derivative work under a license other
 * than the GPL-compatible Free Software License as defined by the Free
 * Software Foundation or approved by OSI, you must first obtain a commercial
 * license to this software product from Volker Bergmann.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * WITHOUT A WARRANTY OF ANY KIND. ALL EXPRESS OR IMPLIED CONDITIONS,
 * REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE
 * HEREBY EXCLUDED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package org.databene.jdbacl.model.jdbc;

import org.databene.commons.ConnectFailedException;
import org.databene.commons.ErrorHandler;
import org.databene.commons.Escalator;
import org.databene.commons.Filter;
import org.databene.commons.ImportFailedException;
import org.databene.commons.LoggerEscalator;
import org.databene.commons.ObjectNotFoundException;
import org.databene.commons.ProgrammerError;
import org.databene.commons.StringUtil;
import org.databene.commons.Level;
import org.databene.commons.collection.OrderedNameMap;
import org.databene.commons.version.VersionNumber;
import org.databene.jdbacl.DBUtil;
import org.databene.jdbacl.DatabaseDialect;
import org.databene.jdbacl.DatabaseDialectManager;
import org.databene.jdbacl.JDBCConnectData;
import org.databene.jdbacl.dialect.OracleDialect;
import org.databene.jdbacl.model.DBSequence;
import org.databene.jdbacl.model.FKChangeRule;
import org.databene.jdbacl.model.DBCatalog;
import org.databene.jdbacl.model.DBCheckConstraint;
import org.databene.jdbacl.model.DBColumn;
import org.databene.jdbacl.model.DBDataType;
import org.databene.jdbacl.model.DBForeignKeyConstraint;
import org.databene.jdbacl.model.DBMetaDataImporter;
import org.databene.jdbacl.model.DBIndex;
import org.databene.jdbacl.model.DBNonUniqueIndex;
import org.databene.jdbacl.model.DBPrimaryKeyConstraint;
import org.databene.jdbacl.model.DBSchema;
import org.databene.jdbacl.model.DBTable;
import org.databene.jdbacl.model.DBUniqueConstraint;
import org.databene.jdbacl.model.DBUniqueIndex;
import org.databene.jdbacl.model.Database;
import org.databene.jdbacl.model.DefaultDBColumn;
import org.databene.jdbacl.model.DefaultDBTable;
import org.databene.jdbacl.model.DefaultDatabase;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.*;
import java.util.Date;
import java.util.regex.Pattern;

/**
 * Imports a DB model via JDBC.&lt;br/&gt;&lt;br/&gt;
 * Created: 06.01.2007 19:16:45
 * @author Volker Bergmann
 */
public final class JDBCDBImporter implements DBMetaDataImporter {

<span class="fc" id="L80">    private static final Logger LOGGER = LoggerFactory.getLogger(JDBCDBImporter.class);</span>

    String url;
    String driver;
    String password;
    final String user;
    String catalogName;
    String schemaName;
    Pattern includeTables;
    Pattern excludeTables;
    boolean importingIndexes;
<span class="fc" id="L91">	boolean importingUKs = true;</span>
<span class="fc" id="L92">	boolean importingSequences = false;</span>
<span class="fc" id="L93">	boolean importingChecks = true;</span>
<span class="fc" id="L94">	boolean importingTriggers = false;</span>
<span class="fc" id="L95">	boolean importingPackages = false;</span>
<span class="fc" id="L96">	boolean lazy = false;</span>
	
    Connection _connection;
    DatabaseDialect dialect;
    String databaseProductName;

<span class="fc" id="L102">    Escalator escalator = new LoggerEscalator();</span>
    ErrorHandler errorHandler;
    TableNameFilter tableNameFilter;

	DatabaseMetaData metaData;
	DefaultDatabase database;

    public JDBCDBImporter(String environment) {
<span class="nc" id="L110">        this(DBUtil.getConnectData(environment));</span>
<span class="nc" id="L111">    }</span>

    public JDBCDBImporter(JDBCConnectData cd) {
<span class="fc" id="L114">    	this(cd.url, cd.driver, cd.user, cd.password, cd.catalog, cd.schema);</span>
<span class="fc" id="L115">	}</span>

    public JDBCDBImporter(String url, String driver, String user, String password, String catalog, String schema) {
<span class="fc" id="L118">        this(url, driver, user, password, catalog, schema, &quot;.*&quot;, true);</span>
<span class="fc" id="L119">    }</span>

    public JDBCDBImporter(String url, String driver, String user, String password, String catalog, String schema, 
<span class="fc" id="L122">    		String tablePattern, boolean importingIndexes) {</span>
<span class="fc" id="L123">    	this._connection = null;</span>
<span class="fc" id="L124">        this.url = url;</span>
<span class="fc" id="L125">        this.driver = driver;</span>
<span class="fc" id="L126">        this.user = user;</span>
<span class="fc" id="L127">        this.password = password;</span>
<span class="fc" id="L128">        this.catalogName = catalog;</span>
<span class="fc" id="L129">        this.schemaName = schema;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        this.includeTables = Pattern.compile(tablePattern != null ? tablePattern : &quot;.*&quot;);</span>
<span class="fc" id="L131">        this.importingIndexes = importingIndexes;</span>
<span class="fc" id="L132">        this.errorHandler = new ErrorHandler(getClass().getName(), Level.error);</span>
<span class="fc" id="L133">    }</span>

<span class="fc" id="L135">    public JDBCDBImporter(Connection connection, String user, String schemaName) {</span>
<span class="fc" id="L136">    	this._connection = connection;</span>
<span class="fc" id="L137">        this.user = user;</span>
<span class="fc" id="L138">        this.schemaName = schemaName;</span>
<span class="fc" id="L139">        this.errorHandler = new ErrorHandler(getClass().getName(), Level.error);</span>
<span class="fc" id="L140">        this.importingIndexes = true;</span>
<span class="fc" id="L141">    }</span>

    // properties ------------------------------------------------------------------------------------------------------
    
	/**
     * @return the productName
     */
    public String getDatabaseProductName() {
<span class="fc" id="L149">        return databaseProductName;</span>
    }
    
    public void setFaultTolerant(boolean faultTolerant) {
<span class="nc bnc" id="L153" title="All 2 branches missed.">    	this.errorHandler = new ErrorHandler(getClass().getName(), (faultTolerant ? Level.warn : Level.error));</span>
<span class="nc" id="L154">    }</span>

	public Connection getConnection() throws ConnectFailedException {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">		if (this._connection == null)</span>
<span class="nc" id="L158">			this._connection = DBUtil.connect(url, driver, user, password, true);</span>
<span class="fc" id="L159">	    return this._connection;</span>
    }

    @Deprecated
	public void setTablePattern(Pattern tablePattern) {
<span class="nc" id="L164">    	this.includeTables = tablePattern;</span>
<span class="nc" id="L165">    }</span>

	public void setIncludeTables(String includeTables) {
<span class="nc bnc" id="L168" title="All 2 branches missed.">    	this.includeTables = (StringUtil.isEmpty(includeTables) ? null : Pattern.compile(includeTables));</span>
<span class="nc" id="L169">    }</span>

	public void setExcludeTables(String excludeTables) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">    	this.excludeTables = (StringUtil.isEmpty(excludeTables) ? null : Pattern.compile(excludeTables));</span>
<span class="nc" id="L173">    }</span>

	public boolean isImportingIndexes() {
<span class="fc" id="L176">    	return importingIndexes;</span>
    }

	public void setImportingIndexes(boolean importingIndexes) {
<span class="nc" id="L180">    	this.importingIndexes = importingIndexes;</span>
<span class="nc" id="L181">    }</span>

	public void setImportingUKs(boolean importingUKs) {
<span class="nc" id="L184">		this.importingUKs  = importingUKs;</span>
<span class="nc" id="L185">    }</span>
	
	public void setImportingChecks(boolean importingChecks) {
<span class="nc" id="L188">		this.importingChecks = importingChecks;</span>
<span class="nc" id="L189">	}</span>
	
	public void setImportingSequences(boolean importingSequences) {
<span class="nc" id="L192">		this.importingSequences = importingSequences;</span>
<span class="nc" id="L193">	}</span>
	
	public void setImportingTriggers(boolean importingTriggers) {
<span class="nc" id="L196">		this.importingTriggers = importingTriggers;</span>
<span class="nc" id="L197">	}</span>

	public boolean isImportingPackages() {
<span class="fc" id="L200">		return importingPackages;</span>
	}

	public void setImportingPackages(boolean importingPackages) {
<span class="nc" id="L204">		this.importingPackages = importingPackages;</span>
<span class="nc" id="L205">	}</span>

	public void setSchemaName(String schemaName) {
<span class="nc" id="L208">	    this.schemaName = schemaName;</span>
<span class="nc" id="L209">    }</span>
    
    public void setCatalogName(String catalogName) {
<span class="nc" id="L212">	    this.catalogName = catalogName;</span>
<span class="nc" id="L213">    }</span>
    
	public void setLazy(boolean lazy) {
<span class="nc" id="L216">    	this.lazy = lazy;</span>
<span class="nc" id="L217">    }</span>

	// functional interface --------------------------------------------------------------------------------------------
	
	public Database importDatabase() throws ConnectFailedException, ImportFailedException {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">		if (!lazy)</span>
<span class="fc" id="L223">			LOGGER.info(&quot;Importing database metadata. Be patient, this may take some time...&quot;);</span>
<span class="fc" id="L224">        long startTime = System.currentTimeMillis();</span>
<span class="fc" id="L225">        tableNameFilter = new TableNameFilter();</span>
        try {
<span class="nc" id="L227">            metaData = getConnection().getMetaData();</span>
<span class="nc" id="L228">            databaseProductName = metaData.getDatabaseProductName();</span>
<span class="nc" id="L229">            VersionNumber productVersion = VersionNumber.valueOf(metaData.getDatabaseMajorVersion() + &quot;.&quot; + </span>
            		metaData.getDatabaseMinorVersion());
<span class="nc" id="L231">            LOGGER.debug(&quot;Product: {} {}&quot;, databaseProductName, productVersion);</span>
<span class="nc" id="L232">            dialect = DatabaseDialectManager.getDialectForProduct(databaseProductName, productVersion);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (isOracle()) // fix for Oracle varchar column size, see http://kr.forums.oracle.com/forums/thread.jspa?threadID=554236</span>
<span class="nc" id="L234">            	DBUtil.executeUpdate(&quot;ALTER SESSION SET NLS_LENGTH_SEMANTICS=CHAR&quot;, getConnection());</span>
<span class="nc" id="L235">            database = new DefaultDatabase(databaseProductName, databaseProductName, productVersion);</span>
<span class="nc" id="L236">        	database.setImportDate(new Date());</span>
<span class="nc" id="L237">        	database.setUser(user);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        	database.setTableInclusionPattern(includeTables != null ? includeTables.pattern() : null);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        	database.setTableExclusionPattern(excludeTables != null ? excludeTables.pattern() : null);</span>
<span class="nc" id="L240">        	database.setImportedChecks(importingChecks);</span>
<span class="nc" id="L241">        	database.setImportedUKs(importingUKs);</span>
<span class="nc" id="L242">        	database.setImportedIndexes(importingIndexes);</span>
<span class="nc" id="L243">        	database.setImportedSequences(importingSequences);</span>
<span class="nc" id="L244">            importCatalogs();</span>
<span class="nc" id="L245">            importSchemas();</span>
<span class="nc" id="L246">            importTables();</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">            if (importingSequences &amp;&amp; dialect.isSequenceSupported())</span>
<span class="nc" id="L248">            	importSequences();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (!lazy) {</span>
<span class="nc" id="L250">            	importColumns();</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">	            if (importingIndexes || importingUKs)</span>
<span class="nc" id="L252">	                importIndexes();</span>
<span class="nc" id="L253">            	importPrimaryKeys();</span>
<span class="nc" id="L254">	            importImportedKeys();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">	            if (importingChecks)</span>
<span class="nc" id="L256">	            	importChecks();</span>
            }
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (importingTriggers)</span>
<span class="nc" id="L259">            	importTriggers();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (importingPackages)</span>
<span class="nc" id="L261">            	importPackages();</span>
<span class="nc" id="L262">            long duration = System.currentTimeMillis() - startTime;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            LOGGER.info(&quot;Imported&quot; + (lazy ? &quot; core&quot; : &quot;&quot;) + &quot; database metadata within &quot; + duration + &quot; ms.&quot;);</span>
<span class="nc" id="L264">            return database;</span>
<span class="nc" id="L265">        } catch (SQLException e) {</span>
<span class="nc" id="L266">            throw new ImportFailedException(e);</span>
        }
    }

	public void close() {
<span class="nc" id="L271">        DBUtil.close(_connection);</span>
<span class="nc" id="L272">	}</span>
	
	// private helper methods ------------------------------------------------------------------------------------------

	private void importCatalogs() throws SQLException, ConnectFailedException {
<span class="nc" id="L277">        LOGGER.debug(&quot;Importing catalogs&quot;);</span>
<span class="nc" id="L278">        ResultSet catalogSet = metaData.getCatalogs();</span>
<span class="nc" id="L279">        int catalogCount = 0;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        while (catalogSet.next()) {</span>
<span class="nc" id="L281">            String foundCatalog = catalogSet.getString(1);</span>
<span class="nc" id="L282">            LOGGER.debug(&quot;found catalog '&quot; + foundCatalog + &quot;'&quot;);</span>
<span class="nc bnc" id="L283" title="All 8 branches missed.">            if (StringUtil.equalsIgnoreCase(foundCatalog, this.catalogName) // this is the configured catalog</span>
            		|| (StringUtil.isEmpty(this.catalogName) &amp;&amp; ( // no catalog configured but...
            				dialect.isDefaultCatalog(foundCatalog, user) // ...the one found is the default for the database
            				|| foundCatalog.equalsIgnoreCase(getConnection().getCatalog()) // or for the connection
            		))) {
<span class="nc" id="L288">                this.catalogName = foundCatalog;</span>
<span class="nc" id="L289">                database.addCatalog(new DBCatalog(foundCatalog));</span>
<span class="nc" id="L290">                catalogCount++;</span>
            }
<span class="nc" id="L292">        }</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (catalogCount == 0)</span>
<span class="nc" id="L294">            database.addCatalog(new DBCatalog(null));</span>
<span class="nc" id="L295">        catalogSet.close();</span>
<span class="nc" id="L296">    }</span>

    private void importSchemas() throws SQLException {
<span class="nc" id="L299">        LOGGER.debug(&quot;Importing schemas&quot;);</span>
<span class="nc" id="L300">        int schemaCount = 0;</span>
<span class="nc" id="L301">        ResultSet schemaSet = metaData.getSchemas();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        while (schemaSet.next()) {</span>
<span class="nc" id="L303">            String schemaName = schemaSet.getString(1);</span>
<span class="nc" id="L304">            String catalogName = null;</span>
<span class="nc" id="L305">            int columnCount = schemaSet.getMetaData().getColumnCount();</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">			if (columnCount &gt;= 2)</span>
<span class="nc" id="L307">            	catalogName = schemaSet.getString(2);</span>
<span class="nc bnc" id="L308" title="All 6 branches missed.">            if (schemaName.equalsIgnoreCase(this.schemaName) </span>
            		|| (this.schemaName == null &amp;&amp; dialect.isDefaultSchema(schemaName, user))) {
<span class="nc" id="L310">	            LOGGER.debug(&quot;importing schema '{}'&quot;, schemaName);</span>
<span class="nc" id="L311">	        	this.schemaName = schemaName; // take over capitalization used in the DB</span>
<span class="nc" id="L312">	            DBSchema schema = new DBSchema(schemaName);</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">	            String catalogNameOfSchema = (columnCount &gt;= 2 &amp;&amp; catalogName != null ? catalogName : this.catalogName); // PostgreSQL and SQL Server do not necessarily tell you the catalog name</span>
<span class="nc" id="L314">            	DBCatalog catalogOfSchema = database.getCatalog(catalogNameOfSchema);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            	if (catalogOfSchema != null)</span>
<span class="nc" id="L316">            		catalogOfSchema.addSchema(schema);</span>
            	else
<span class="nc" id="L318">            		throw new ObjectNotFoundException(&quot;Catalog not found: &quot; + catalogOfSchema);</span>
<span class="nc" id="L319">	            schemaCount++;</span>
<span class="nc" id="L320">            } else</span>
<span class="nc" id="L321">                LOGGER.debug(&quot;ignoring schema {}&quot;, schemaName);</span>
<span class="nc" id="L322">        }</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (schemaCount == 0) {</span>
        	// add a default schema if none was reported (e.g. by MySQL)
<span class="nc" id="L325">        	DBCatalog catalogToUse = database.getCatalog(catalogName);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        	if (catalogToUse == null)</span>
<span class="nc" id="L327">        		catalogToUse = database.getCatalogs().get(0);</span>
<span class="nc" id="L328">       		catalogToUse.addSchema(new DBSchema(null));</span>
        }
<span class="nc" id="L330">        schemaSet.close();</span>
<span class="nc" id="L331">    }</span>

	private void importTables() throws SQLException {
<span class="nc" id="L334">        LOGGER.info(&quot;Importing tables&quot;);</span>
<span class="nc" id="L335">        ResultSet tableSet = metaData.getTables(catalogName, schemaName, null, new String[] { &quot;TABLE&quot;, &quot;VIEW&quot; });</span>
<span class="nc" id="L336">        List&lt;DBTable&gt; importedTables = new ArrayList&lt;DBTable&gt;();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        while (tableSet.next()) {</span>

            // parsing ResultSet line
<span class="nc" id="L340">            String tCatalogName = tableSet.getString(1);</span>
<span class="nc" id="L341">            String tSchemaName = tableSet.getString(2);</span>
<span class="nc" id="L342">            String tableName = tableSet.getString(3);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (tableName.startsWith(&quot;BIN$&quot;)) {</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">                if (isOracle() &amp;&amp; tableName.startsWith(&quot;BIN$&quot;))</span>
<span class="nc" id="L345">                    escalator.escalate(&quot;BIN$ table found (for improved performance &quot; +</span>
                                &quot;execute 'PURGE RECYCLEBIN;')&quot;, this, tableName);
                continue;
            }
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (!tableSupported(tableName)) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L351">                    LOGGER.debug(&quot;ignoring table: &quot; + tCatalogName + &quot;, &quot; + tSchemaName + &quot;, &quot; + tableName);</span>
            	continue;
            }
<span class="nc" id="L354">            String tableType = tableSet.getString(4); // Typical types are &quot;TABLE&quot;, &quot;VIEW&quot;, &quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;, &quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;</span>
<span class="nc" id="L355">            String tableRemarks = tableSet.getString(5);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L357">                LOGGER.debug(&quot;importing table: &quot; + tCatalogName + &quot;, &quot; + tSchemaName + &quot;, &quot; + tableName + &quot;, &quot; + tableType + &quot;, &quot; + tableRemarks);</span>

<span class="nc" id="L359">            DBCatalog catalog = database.getCatalog(tCatalogName);</span>
			DBSchema schema;
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (catalog != null) {</span>
            	// that's the expected way
<span class="nc" id="L363">            	schema = catalog.getSchema(tSchemaName);</span>
            } else {
            	// postgres returns no catalog info, so we need to search for the schema in the whole database
<span class="nc" id="L366">            	schema = database.getSchema(tSchemaName);</span>
<span class="nc" id="L367">            	catalog = schema.getCatalog();</span>
            }
<span class="nc bnc" id="L369" title="All 4 branches missed.">			if (catalog != null &amp;&amp; schema != null) {</span>
<span class="nc" id="L370">				DBTable table = createTable(catalog, schema, tableName, tableRemarks, lazy);</span>
<span class="nc" id="L371">	            importedTables.add(table);</span>
<span class="nc" id="L372">			} else {</span>
<span class="nc" id="L373">				LOGGER.warn(&quot;ignoring table &quot; + tableName);</span>
			}
<span class="nc" id="L375">        }</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (!lazy)</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        	for (DBTable table : importedTables)</span>
<span class="nc" id="L378">        		importTableDetails((DefaultDBTable) table);</span>
<span class="nc" id="L379">        tableSet.close();</span>
<span class="nc" id="L380">    }</span>

	DefaultDBTable importTable(DBCatalog catalog, DBSchema schema, String tableName, String remarks) {
<span class="nc" id="L383">		DefaultDBTable table = (DefaultDBTable) createTable(catalog, schema, tableName, remarks, false);</span>
<span class="nc" id="L384">		importTableDetails(table);</span>
<span class="nc" id="L385">        return table;</span>
    }

	private void importTableDetails(DefaultDBTable table) {
<span class="nc" id="L389">	    importColumns(table.getCatalog(), table.getSchema().getName(), table.getName(), null, null);</span>
<span class="nc" id="L390">	    importPrimaryKeys(table);</span>
<span class="nc" id="L391">	    importImportedKeys(table);</span>
<span class="nc" id="L392">	    importRefererTables(table);</span>
<span class="nc" id="L393">    }</span>

	private DBTable createTable(DBCatalog catalog, DBSchema schema, String tableName, String remarks, boolean lazy) {
	    DBTable table;
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">		if (lazy) {</span>
<span class="nc" id="L398">			table = new LazyTable(this, schema, tableName, remarks);</span>
		} else {
<span class="fc" id="L400">			DefaultDBTable dTable = new DefaultDBTable(tableName, schema);</span>
<span class="fc" id="L401">			dTable.setDoc(remarks);</span>
<span class="fc" id="L402">			table = dTable;</span>
		}
<span class="fc" id="L404">	    return table;</span>
    }

	private boolean isOracle() {
<span class="nc" id="L408">		return databaseProductName.toLowerCase().startsWith(&quot;oracle&quot;);</span>
	}

    private void importColumns() {
<span class="nc bnc" id="L412" title="All 2 branches missed.">		if (this.catalogName != null)</span>
<span class="nc" id="L413">			importColumns(database.getCatalog(this.catalogName), this.schemaName, null, tableNameFilter, errorHandler);</span>
		else
<span class="nc bnc" id="L415" title="All 2 branches missed.">			for (DBCatalog catalog : database.getCatalogs()) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">				for (DBSchema schema : catalog.getSchemas())</span>
<span class="nc" id="L417">					importColumns(catalog, schema.getName(), null, tableNameFilter, errorHandler);</span>
<span class="nc" id="L418">			}</span>
<span class="nc" id="L419">    }</span>

    private void importColumns(DBCatalog catalog, String schemaName, String tablePattern, Filter&lt;String&gt; tableFilter, ErrorHandler errorHandler) {
<span class="fc" id="L422">        String catalogName = catalog.getName();</span>
<span class="pc bpc" id="L423" title="3 of 4 branches missed.">        String schemaPattern = (schemaName != null ? schemaName : (catalog.getSchemas().size() == 1 ? catalog.getSchemas().get(0).getName() : null));</span>
<span class="fc" id="L424">        LOGGER.debug(&quot;Importing columns for &quot; +</span>
        		&quot;catalog &quot; + StringUtil.quoteIfNotNull(catalogName) + &quot;, &quot; +
        		&quot;schemaPattern &quot; + StringUtil.quoteIfNotNull(schemaName) + &quot;, &quot; +
        		&quot;tablePattern '&quot; + StringUtil.quoteIfNotNull(tablePattern) + &quot;'&quot;);
<span class="fc" id="L428">        ResultSet columnSet = null;</span>
        try {
<span class="nc" id="L430">        	columnSet = metaData.getColumns(catalogName, schemaPattern, tablePattern, null);</span>
<span class="nc" id="L431">	        ResultSetMetaData setMetaData = columnSet.getMetaData();</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">	        if (setMetaData.getColumnCount() == 0)</span>
	            return;
<span class="nc bnc" id="L434" title="All 2 branches missed.">	        while (columnSet.next()) {</span>
<span class="nc" id="L435">	            String colSchemaName = columnSet.getString(2);</span>
<span class="nc" id="L436">	            String tableName = columnSet.getString(3);</span>
<span class="nc" id="L437">	            String columnName = columnSet.getString(4);</span>
<span class="nc bnc" id="L438" title="All 6 branches missed.">	            if (tableName.startsWith(&quot;BIN$&quot;) || (tableFilter != null &amp;&amp; !tableFilter.accept(tableName))) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">	            	if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L440">	            		LOGGER.debug(&quot;ignoring column &quot; + catalogName + &quot;.&quot; + colSchemaName + &quot;.&quot; + tableName + &quot;.&quot; + columnName);</span>
	                continue;
	            }
<span class="nc" id="L443">	            int sqlType = columnSet.getInt(5);</span>
<span class="nc" id="L444">	            String columnType = columnSet.getString(6);</span>
<span class="nc" id="L445">	            Integer columnSize = columnSet.getInt(7);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">	            if (columnSize == 0) // happens with INTEGER values on HSQLDB</span>
<span class="nc" id="L447">	            	columnSize = null;</span>
<span class="nc" id="L448">	            int decimalDigits = columnSet.getInt(9);</span>
<span class="nc" id="L449">	            boolean nullable = columnSet.getBoolean(11);</span>
<span class="nc" id="L450">	            String comment = columnSet.getString(12);</span>
<span class="nc" id="L451">	            String defaultValue = columnSet.getString(13);</span>

	            // Bug fix 3075401: boolean value generation problem in postgresql 8.4
<span class="nc bnc" id="L454" title="All 6 branches missed.">	            if (sqlType == Types.BIT &amp;&amp; &quot;bool&quot;.equals(columnType.toLowerCase()) &amp;&amp; databaseProductName.toLowerCase().startsWith(&quot;postgres&quot;)) {</span>
<span class="nc" id="L455">	            	sqlType = Types.BOOLEAN;</span>
	            }
	            
<span class="nc bnc" id="L458" title="All 2 branches missed.">	            if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L459">	            	LOGGER.debug(&quot;found column: &quot; + catalogName + &quot;, &quot; + colSchemaName + &quot;, &quot; + tableName + &quot;, &quot;</span>
	                        + columnName + &quot;, &quot; + sqlType + &quot;, &quot; + columnType + &quot;, &quot; + columnSize + &quot;, &quot; + decimalDigits
	                        + &quot;, &quot; + nullable + &quot;, &quot; + comment + &quot;, &quot; + defaultValue);
	
<span class="nc" id="L463">	            DBTable table = catalog.getTable(tableName, false);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">	            if (table == null) {</span>
<span class="nc" id="L465">	            	LOGGER.debug(&quot;Ignoring column {}.{}&quot;, tableName, columnName);</span>
<span class="nc" id="L466">	            	continue; // PostgreSQL returns the columns of indexes, too</span>
	            }
<span class="nc" id="L468">	            DBSchema schema = catalog.getSchema(schemaName);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">	            if (schema != null)</span>
<span class="nc" id="L470">	                table = (DefaultDBTable) schema.getTable(tableName);</span>

<span class="nc bnc" id="L472" title="All 2 branches missed.">	            Integer fractionDigits = (decimalDigits &gt; 0 ? decimalDigits : null);</span>
<span class="nc" id="L473">	            DefaultDBColumn column = new DefaultDBColumn(columnName, table, DBDataType.getInstance(sqlType, columnType), columnSize, fractionDigits);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">	            if (!StringUtil.isEmpty(comment))</span>
<span class="nc" id="L475">	                column.setDoc(comment);</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">	            if (!StringUtil.isEmpty(defaultValue)) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">	                if (!column.getType().isAlpha())</span>
<span class="nc" id="L478">	                    defaultValue = removeBrackets(defaultValue); // some driver adds brackets to number defaults</span>
<span class="nc" id="L479">	                column.setDefaultValue(defaultValue.trim()); // oracle thin driver produces &quot;1 &quot;</span>
	            }
<span class="nc bnc" id="L481" title="All 2 branches missed.">	            if (!nullable)</span>
<span class="nc" id="L482">	                column.setNullable(false);</span>
	
	            // not used: importVersionColumnInfo(catalogName, table, metaData);
<span class="nc" id="L485">	        }</span>
<span class="nc" id="L486">    	} catch (SQLException e) {</span>
    		// possibly we try to access a catalog to which we do not have access rights
<span class="nc bnc" id="L488" title="All 2 branches missed.">    		if (errorHandler == null)</span>
<span class="nc" id="L489">    			errorHandler = new ErrorHandler(getClass());</span>
<span class="nc" id="L490">    		errorHandler.handleError(&quot;Error in parsing columns of catalog &quot; + catalog.getName(), e);</span>
        } finally {
<span class="pc" id="L492">        	DBUtil.close(columnSet);</span>
<span class="nc" id="L493">        }</span>
<span class="nc" id="L494">    }</span>

    private static String removeBrackets(String defaultValue) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (StringUtil.isEmpty(defaultValue))</span>
<span class="nc" id="L498">            return defaultValue;</span>
<span class="nc bnc" id="L499" title="All 4 branches missed.">        if (!defaultValue.startsWith(&quot;(&quot;) || !defaultValue.endsWith(&quot;)&quot;))</span>
<span class="nc" id="L500">            return defaultValue;</span>
<span class="nc" id="L501">        return removeBrackets(defaultValue.substring(1, defaultValue.length() - 1));</span>
    }

    
/*
    private void importVersionColumnInfo(DBCatalog catalogName, DBTable table, DatabaseMetaData metaData) throws SQLException {
        ResultSet versionColumnSet = metaData.getVersionColumns(catalogName.getName(), null, table.getName());
//        DBUtil.print(versionColumnSet);
        while (versionColumnSet.next()) {
            // short scope = versionColumnSet.getString(1);
            String columnName = versionColumnSet.getString(2);
            //int dataType = versionColumnSet.getInt(3);
            //String typeName = versionColumnSet.getString(4);
            //int columnSize = versionColumnSet.getInt(5);
            //int bufferLength = versionColumnSet.getInt(6);
            //short decimalDigits = versionColumnSet.getShort(7);
            //short pseudoColumn = versionColumnSet.getShort(8);
            DBColumn column = table.getColumn(columnName);
            column.setVersionColumn(true);
        }
    }
*/
    private void importPrimaryKeys() {
<span class="nc" id="L524">        int count = 0;</span>
<span class="nc" id="L525">        DBSchema schema = database.getCatalog(catalogName).getSchema(schemaName);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (schema != null)</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            for (DBTable table : schema.getTables()) {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                if (!tableSupported(table.getName()))</span>
<span class="nc" id="L529">                	continue;</span>
<span class="nc" id="L530">                importPrimaryKeys((DefaultDBTable) table);</span>
<span class="nc" id="L531">                count++;</span>
<span class="nc" id="L532">            }</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (count &gt; 0)</span>
<span class="nc" id="L534">            return;</span>
<span class="nc" id="L535">        DBCatalog catalog = database.getCatalog(catalogName);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (catalog != null)</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            for (DBTable table : catalog.getTables()) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (!tableSupported(table.getName()))</span>
<span class="nc" id="L539">                	continue;</span>
<span class="nc" id="L540">                importPrimaryKeys((DefaultDBTable) table);</span>
<span class="nc" id="L541">            }</span>
<span class="nc" id="L542">    }</span>

    private void importPrimaryKeys(DefaultDBTable table) {
<span class="nc" id="L545">        LOGGER.debug(&quot;Importing primary keys for table &quot; + table);</span>
<span class="nc" id="L546">        ResultSet pkset = null;</span>
        try {
<span class="nc" id="L548">	        pkset = metaData.getPrimaryKeys(catalogName, schemaName, table.getName());</span>
<span class="nc" id="L549">	        TreeMap&lt;Short, String&gt; pkComponents = new TreeMap&lt;Short, String&gt;();</span>
<span class="nc" id="L550">	        String pkName = null;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">	        while (pkset.next()) {</span>
<span class="nc" id="L552">	        	String tableName = pkset.getString(3);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">	            if (!tableName.equals(table.getName())) // Bug fix for Firebird: </span>
<span class="nc" id="L554">	            	continue;							// When querying X, it returns the pks of XY too</span>
	
<span class="nc" id="L556">	            String columnName = pkset.getString(4);</span>
<span class="nc" id="L557">	            short keySeq = pkset.getShort(5);</span>
<span class="nc" id="L558">	            pkComponents.put(keySeq, columnName);</span>
<span class="nc" id="L559">	            pkName = pkset.getString(6);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">	            if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L561">	                LOGGER.debug(&quot;found pk column &quot; + columnName + &quot;, &quot; + keySeq + &quot;, &quot; + pkName);</span>
<span class="nc" id="L562">	        }</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">	        if (pkComponents.size() &gt; 0) {</span>
<span class="nc" id="L564">		        String[] columnNames = pkComponents.values().toArray(new String[pkComponents.size()]);</span>
<span class="nc" id="L565">		        DBPrimaryKeyConstraint constraint = new DBPrimaryKeyConstraint(table, pkName, dialect.isDeterministicPKName(pkName), columnNames);</span>
<span class="nc" id="L566">		        table.setPrimaryKey(constraint);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">		        for (String columnName : columnNames) {</span>
<span class="nc" id="L568">		        	DBColumn column = table.getColumn(columnName);</span>
<span class="nc" id="L569">		            column.addUkConstraint(constraint);</span>
		        }
	        }
<span class="nc" id="L572">        } catch (SQLException e) {</span>
<span class="nc" id="L573">        	errorHandler.handleError(&quot;Error importing primary key of table &quot; + table.getName());</span>
        } finally {
<span class="nc" id="L575">        	DBUtil.close(pkset);</span>
<span class="nc" id="L576">        }</span>
<span class="nc" id="L577">    }</span>

    private void importIndexes() {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        for (DBCatalog catalog : database.getCatalogs())</span>
<span class="nc" id="L581">       		importIndexes(catalog, metaData);</span>
<span class="nc" id="L582">    }</span>

	private void importIndexes(DBCatalog catalog, DatabaseMetaData metaData) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">	    for (DBSchema schema : catalog.getSchemas()) {</span>
<span class="nc" id="L586">	        LOGGER.debug(&quot;Importing indexes for schema '&quot; + schema.getName() + &quot;'&quot;);</span>
<span class="nc" id="L587">	        OrderedNameMap&lt;DBIndexInfo&gt; indexes = new OrderedNameMap&lt;DBIndexInfo&gt;();</span>
<span class="nc" id="L588">	        ResultSet indexSet = null;</span>
	        try {
<span class="nc bnc" id="L590" title="All 2 branches missed.">		        indexSet = metaData.getIndexInfo(catalog.getName(), schema.getName(), null, !importingIndexes, false);</span>
		        //DBUtil.print(indexSet);
<span class="nc bnc" id="L592" title="All 2 branches missed.">		        while (indexSet.next()) {</span>
<span class="nc" id="L593">		            String indexName = null;</span>
		            try {
<span class="nc" id="L595">		            	String tableName = indexSet.getString(3);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">		    	    	if (!tableSupported(tableName))</span>
<span class="nc" id="L597">		    	    		continue;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">		                boolean unique = !indexSet.getBoolean(4);</span>
<span class="nc" id="L599">		                String indexCatalogName = indexSet.getString(5);</span>
<span class="nc" id="L600">		                indexName = indexSet.getString(6);</span>
<span class="nc" id="L601">		                short indexType = indexSet.getShort(7);</span>
		                // not used: 
		                // tableIndexStatistic - this identifies table statistics that are returned in conjuction with a table's index descriptions
		                // tableIndexClustered - this is a clustered index
		                // tableIndexHashed - this is a hashed index
		                // tableIndexOther - this is some other style of index
		                //
<span class="nc" id="L608">		                short ordinalPosition = indexSet.getShort(8);</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">		                if (ordinalPosition == 0)</span>
<span class="nc" id="L610">		                    continue;</span>
<span class="nc" id="L611">		                String columnName = indexSet.getString(9);</span>
<span class="nc" id="L612">		                String ascOrDesc = indexSet.getString(10);</span>
<span class="nc bnc" id="L613" title="All 4 branches missed.">		                Boolean ascending = (ascOrDesc != null ? ascOrDesc.charAt(0) == 'A' : null);</span>
<span class="nc" id="L614">		                int cardinality = indexSet.getInt(11);</span>
<span class="nc" id="L615">		                int pages = indexSet.getInt(12);</span>
<span class="nc" id="L616">		                String filterCondition = indexSet.getString(13);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">		                if (LOGGER.isDebugEnabled())</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">		                    LOGGER.debug(&quot;found &quot; + (unique ? &quot;unique index &quot; : &quot;index &quot;) + indexName + &quot;, &quot; </span>
		                            + indexCatalogName + &quot;, &quot; + indexType + &quot;, &quot; 
		                            + ordinalPosition + &quot;, &quot; + columnName + &quot;, &quot; + ascOrDesc + &quot;, &quot; 
		                            + cardinality + &quot;, &quot; + pages + &quot;, &quot; + filterCondition);
<span class="nc" id="L622">		                DBIndexInfo index = indexes.get(indexName);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">		                if (index == null) {</span>
<span class="nc" id="L624">		                    index = new DBIndexInfo(indexName, tableName, indexType, indexCatalogName, unique,</span>
		                        ordinalPosition, columnName,
		                        ascending, cardinality, pages, filterCondition);
<span class="nc" id="L627">		                    indexes.put(indexName, index);</span>
		                } else {
<span class="nc" id="L629">		                    index.addColumn(ordinalPosition, columnName);</span>
		                }
<span class="nc" id="L631">		            } catch (Exception e) {</span>
<span class="nc" id="L632">		            	LOGGER.error(&quot;Error parsing indexes: &quot;, e);</span>
<span class="nc" id="L633">		            }</span>
<span class="nc" id="L634">		        }</span>
<span class="nc" id="L635">	        } catch (SQLException e) {</span>
        		// possibly we try to query a catalog to which we do not have access rights
<span class="nc" id="L637">        		errorHandler.handleError(&quot;Error parsing index data of schema &quot; + schema.getName(), e);</span>
			} finally {
<span class="nc" id="L639">	        	DBUtil.close(indexSet);</span>
<span class="nc" id="L640">	        }</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">	        for (DBIndexInfo indexInfo : indexes.values()) {</span>
<span class="nc" id="L642">                DBIndex index = null;</span>
	            try {
<span class="nc" id="L644">	            	DBTable table = schema.getTable(indexInfo.tableName);</span>
<span class="nc" id="L645">                    boolean deterministicName = dialect.isDeterministicIndexName(indexInfo.name);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">	                if (indexInfo.unique) {</span>
<span class="nc" id="L647">	                	DBPrimaryKeyConstraint pk = table.getPrimaryKeyConstraint();</span>
<span class="nc bnc" id="L648" title="All 4 branches missed.">	                	boolean isPK = (pk != null &amp;&amp; StringUtil.equalsIgnoreCase(indexInfo.columnNames, pk.getColumnNames()));</span>
	                	DBUniqueConstraint constraint;
<span class="nc bnc" id="L650" title="All 2 branches missed.">	                	if (isPK) {</span>
<span class="nc" id="L651">	                		constraint = pk;</span>
	                	} else {
<span class="nc" id="L653">	                		constraint = new DBUniqueConstraint(table, indexInfo.name, dialect.isDeterministicUKName(indexInfo.name), indexInfo.columnNames);</span>
<span class="nc" id="L654">		                    ((DefaultDBTable) table).addUniqueConstraint(constraint);</span>
	                	}
<span class="nc" id="L656">						index = new DBUniqueIndex(indexInfo.name, deterministicName, constraint);</span>
<span class="nc" id="L657">		                ((DefaultDBTable) table).addIndex(index);</span>
<span class="nc" id="L658">	                } else {</span>
<span class="nc" id="L659">	                    index = new DBNonUniqueIndex(indexInfo.name, deterministicName, table, indexInfo.columnNames);</span>
<span class="nc" id="L660">		                ((DefaultDBTable) table).addIndex(index);</span>
	                }
<span class="nc" id="L662">	            } catch (ObjectNotFoundException e) {</span>
<span class="nc" id="L663">	                LOGGER.error(&quot;Error parsing index: &quot; + index, e);</span>
<span class="nc" id="L664">	            }</span>
<span class="nc" id="L665">	        }</span>
<span class="nc" id="L666">	    }</span>
<span class="nc" id="L667">    }</span>

	/*
	private void importIndexes(DBCatalog catalog, DatabaseMetaData metaData) {
	    for (DBTable table : catalog.getTables()) {
	    	if (!tableSupported(table.getName()))
	    		continue;
	        LOGGER.debug(&quot;Importing indexes for table '&quot; + table.getName() + &quot;'&quot;);
	        OrderedNameMap&lt;DBIndexInfo&gt; tableIndexes = new OrderedNameMap&lt;DBIndexInfo&gt;();
	        ResultSet indexSet = null;
	        try {
		        indexSet = metaData.getIndexInfo(catalog.getName(), table.getSchema().getName(), table.getName(), !importingIndexes, false);
		        //DBUtil.print(indexSet);
		        while (indexSet.next()) {
		            String indexName = null;
		            try {
		                boolean unique = !indexSet.getBoolean(4);
		                String indexCatalogName = indexSet.getString(5);
		                indexName = indexSet.getString(6);
		                short indexType = indexSet.getShort(7);
		                // not used: 
		                // tableIndexStatistic - this identifies table statistics that are returned in conjuction with a table's index descriptions
		                // tableIndexClustered - this is a clustered index
		                // tableIndexHashed - this is a hashed index
		                // tableIndexOther - this is some other style of index
		                //
		                short ordinalPosition = indexSet.getShort(8);
		                if (ordinalPosition == 0)
		                    continue;
		                String columnName = indexSet.getString(9);
		                String ascOrDesc = indexSet.getString(10);
		                Boolean ascending = (ascOrDesc != null ? ascOrDesc.charAt(0) == 'A' : null);
		                int cardinality = indexSet.getInt(11);
		                int pages = indexSet.getInt(12);
		                String filterCondition = indexSet.getString(13);
		                if (LOGGER.isDebugEnabled())
		                    LOGGER.debug(&quot;found &quot; + (unique ? &quot;unique index &quot; : &quot;index &quot;) + indexName + &quot;, &quot; 
		                            + indexCatalogName + &quot;, &quot; + indexType + &quot;, &quot; 
		                            + ordinalPosition + &quot;, &quot; + columnName + &quot;, &quot; + ascOrDesc + &quot;, &quot; 
		                            + cardinality + &quot;, &quot; + pages + &quot;, &quot; + filterCondition);
		                DBIndexInfo index = tableIndexes.get(indexName);
		                if (index == null) {
		                    index = new DBIndexInfo(indexName, indexType, indexCatalogName, unique,
		                        ordinalPosition, columnName,
		                        ascending, cardinality, pages, filterCondition);
		                    tableIndexes.put(indexName, index);
		                } else {
		                    index.addColumn(ordinalPosition, columnName);
		                }
		            } catch (Exception e) {
		            	LOGGER.error(&quot;Error parsing indexes: &quot;, e);
		            }
		        }
	        } catch (SQLException e) {
        		// possibly we try to query a catalog to which we do not have access rights
        		errorHandler.handleError(&quot;Error parsing index data of table &quot; + table.getName(), e);
			} finally {
	        	DBUtil.close(indexSet);
	        }
	        for (DBIndexInfo indexInfo : tableIndexes.values()) {
                DBIndex index = null;
	            try {
                    boolean deterministicName = dialect.isDeterministicIndexName(indexInfo.name);
	                if (indexInfo.unique) {
	                	DBPrimaryKeyConstraint pk = table.getPrimaryKeyConstraint();
	                	boolean isPK = (pk != null &amp;&amp; StringUtil.equalsIgnoreCase(indexInfo.columnNames, pk.getColumnNames()));
	                	DBUniqueConstraint constraint;
	                	if (isPK) {
	                		constraint = pk;
	                	} else {
	                		constraint = new DBUniqueConstraint(table, indexInfo.name, dialect.isDeterministicUKName(indexInfo.name), indexInfo.columnNames);
		                    ((DefaultDBTable) table).addUniqueConstraint(constraint);
	                	}
						index = new DBUniqueIndex(indexInfo.name, deterministicName, constraint);
		                ((DefaultDBTable) table).addIndex(index);
	                } else {
	                    index = new DBNonUniqueIndex(indexInfo.name, deterministicName, table, indexInfo.columnNames);
		                ((DefaultDBTable) table).addIndex(index);
	                }
	            } catch (ObjectNotFoundException e) {
	                LOGGER.error(&quot;Error parsing index: &quot; + index, e);
	            }
	        }
	    }
    }
    */
    

    private void importImportedKeys() {
<span class="nc" id="L756">        LOGGER.info(&quot;Importing imported keys&quot;);</span>
<span class="nc" id="L757">        int count = 0;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">        for (DBCatalog catalog : database.getCatalogs())</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">	        for (DBSchema schema : catalog.getSchemas())</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">	            for (DBTable table : schema.getTables()) {</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">	                if (!tableSupported(table.getName()))</span>
<span class="nc" id="L762">	                	continue;</span>
<span class="nc" id="L763">	                importImportedKeys((DefaultDBTable) table);</span>
<span class="nc" id="L764">	                count++;</span>
<span class="nc" id="L765">	            }</span>
<span class="nc" id="L766">    }</span>

    private void importChecks() throws SQLException, ConnectFailedException {
<span class="nc" id="L769">        LOGGER.info(&quot;Importing checks&quot;);</span>
<span class="nc" id="L770">        int count = 0;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (dialect instanceof OracleDialect) {</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">	        for (DBCatalog catalog : database.getCatalogs())</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">		        for (DBSchema schema : catalog.getSchemas()) {</span>
<span class="nc" id="L774">		        	OracleDialect oraDialect = (OracleDialect) dialect;</span>
<span class="nc" id="L775">					DBCheckConstraint[] newChecks = oraDialect.queryCheckConstraints(getConnection(), schema.getName());</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">					for (DBCheckConstraint newCheck : newChecks) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">		                if (!tableSupported(newCheck.getTableName()))</span>
<span class="nc" id="L778">		                	continue;</span>
<span class="nc" id="L779">		                schema.getTable(newCheck.getTableName()).addCheckConstraint(newCheck);</span>
					}
<span class="nc" id="L781">	                count++;</span>
<span class="nc" id="L782">	            }</span>
        }
<span class="nc" id="L784">    }</span>

    private boolean tableSupported(String tableName) {
<span class="nc" id="L787">	    return tableNameFilter.accept(tableName);</span>
    }

    private void importImportedKeys(DefaultDBTable table) {
<span class="nc" id="L791">        LOGGER.debug(&quot;Importing imported keys for table {}&quot;, table.getName());</span>
<span class="nc" id="L792">        DBCatalog catalog = table.getCatalog();</span>
<span class="nc" id="L793">        DBSchema schema = table.getSchema();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">        String catalogName = (catalog != null ? catalog.getName() : null);</span>
<span class="nc" id="L795">        String tableName = table.getName();</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        String schemaName = (schema != null ? schema.getName() : null);</span>
<span class="nc" id="L797">        ResultSet resultSet = null;</span>
        try {
<span class="nc" id="L799">	        resultSet = metaData.getImportedKeys(catalogName, schemaName, tableName);</span>
<span class="nc" id="L800">	        List&lt;ImportedKey&gt; keyList = new ArrayList&lt;ImportedKey&gt;();</span>
<span class="nc" id="L801">	        Map&lt;String, ImportedKey&gt; keysByName = OrderedNameMap.createCaseIgnorantMap();</span>
<span class="nc" id="L802">	        ImportedKey recent = null;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">	        while (resultSet.next()) {</span>
<span class="nc" id="L804">	            ImportedKey cursor = ImportedKey.parse(resultSet, catalog, schema, table);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">	            if (cursor == null) </span>
<span class="nc" id="L806">	            	continue;</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">	            if (cursor.key_seq == 1) {</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">	            	if (cursor.fk_name != null)</span>
<span class="nc" id="L809">	            		keysByName.put(cursor.fk_name, cursor);</span>
<span class="nc" id="L810">            		keyList.add(cursor);</span>
	            } else {
	            	// additional column for a composite FK with columns defined before
<span class="nc bnc" id="L813" title="All 2 branches missed.">		            if (cursor.fk_name != null)</span>
<span class="nc" id="L814">		            	keysByName.get(cursor.fk_name).addForeignKeyColumn(cursor.fkcolumn_name, cursor.pkcolumn_name);</span>
		            else // some systems may not report an fk constraint name
<span class="nc" id="L816">		            	recent.addForeignKeyColumn(cursor.fkcolumn_name, cursor.pkcolumn_name);</span>
	            }
<span class="nc" id="L818">	            recent = cursor;</span>
<span class="nc" id="L819">	        }</span>
	        // build DBForeignKeyConstraint objects from the gathered information
<span class="nc bnc" id="L821" title="All 2 branches missed.">	        for (ImportedKey key : keyList) {</span>
<span class="nc" id="L822">	            int n = key.getForeignKeyColumnNames().size();</span>
<span class="nc" id="L823">	            String[] columnNames = new String[n];</span>
<span class="nc" id="L824">	            String[] refereeColumnNames = new String[n];</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">				for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L826">	                columnNames[i] = key.getForeignKeyColumnNames().get(i); </span>
<span class="nc" id="L827">	                refereeColumnNames[i] = key.getRefereeColumnNames().get(i);</span>
				}
<span class="nc" id="L829">	            DBForeignKeyConstraint foreignKeyConstraint = new DBForeignKeyConstraint(</span>
	            		key.fk_name, dialect.isDeterministicFKName(key.fk_name), table, columnNames, key.getPkTable(), refereeColumnNames);
<span class="nc" id="L831">	            foreignKeyConstraint.setUpdateRule(parseRule(key.update_rule));</span>
<span class="nc" id="L832">	            foreignKeyConstraint.setDeleteRule(parseRule(key.delete_rule));</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">	            if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L834">	            	LOGGER.debug(&quot;Imported foreign key {}&quot;, foreignKeyConstraint);</span>
<span class="nc" id="L835">	        }</span>
<span class="nc" id="L836">        } catch (SQLException e) {</span>
<span class="nc" id="L837">        	errorHandler.handleError(&quot;Error importing foreign key constraints&quot;, e);</span>
        } finally {
<span class="nc" id="L839">	        DBUtil.close(resultSet);</span>
<span class="nc" id="L840">        }</span>
<span class="nc" id="L841">     }</span>

	private FKChangeRule parseRule(short rule) {
<span class="nc bnc" id="L844" title="All 6 branches missed.">		switch (rule) {</span>
<span class="nc" id="L845">			case DatabaseMetaData.importedKeyNoAction:   return FKChangeRule.NO_ACTION;</span>
<span class="nc" id="L846">			case DatabaseMetaData.importedKeyCascade:    return FKChangeRule.CASCADE;</span>
<span class="nc" id="L847">			case DatabaseMetaData.importedKeySetNull:    return FKChangeRule.SET_NULL;</span>
<span class="nc" id="L848">			case DatabaseMetaData.importedKeySetDefault: return FKChangeRule.SET_DEFAULT;</span>
<span class="nc" id="L849">			case DatabaseMetaData.importedKeyRestrict:   return FKChangeRule.NO_ACTION;</span>
<span class="nc" id="L850">			default: throw new ProgrammerError(&quot;Not a supported rule: &quot; + rule);</span>
		}
	}

	private void importRefererTables(DefaultDBTable table) {
<span class="nc" id="L855">        LOGGER.debug(&quot;Importing exported keys for table {}&quot;, table.getName());</span>
<span class="nc" id="L856">        DBCatalog catalog = table.getCatalog();</span>
<span class="nc" id="L857">        DBSchema schema = table.getSchema();</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        String catalogName = (catalog != null ? catalog.getName() : null);</span>
<span class="nc" id="L859">        String tableName = table.getName();</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        String schemaName = (schema != null ? schema.getName() : null);</span>
<span class="nc" id="L861">        ResultSet resultSet = null;</span>
        try {
<span class="nc" id="L863">	        resultSet = metaData.getExportedKeys(catalogName, schemaName, tableName);</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">	        while (resultSet.next()) {</span>
<span class="nc" id="L865">	            String fktable_cat = resultSet.getString(5);</span>
<span class="nc" id="L866">	            String fktable_schem = resultSet.getString(6);</span>
<span class="nc" id="L867">	            String fktable_name = resultSet.getString(7);</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">	            if (tableSupported(fktable_name)) {</span>
<span class="nc" id="L869">		            DBTable referrer = database.getTable(fktable_name);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">		            if (LOGGER.isDebugEnabled())</span>
<span class="nc" id="L871">		            	LOGGER.debug(&quot;Imported referrer: &quot; + referrer);</span>
<span class="nc" id="L872">		            table.addReferrer(referrer);</span>
	            }
<span class="nc" id="L874">	        }</span>
<span class="nc" id="L875">        } catch (SQLException e) {</span>
<span class="nc" id="L876">        	errorHandler.handleError(&quot;Error importing foreign key constraints&quot;, e);</span>
        } finally {
<span class="nc" id="L878">	        DBUtil.close(resultSet);</span>
<span class="nc" id="L879">        }</span>
<span class="nc" id="L880">     }</span>

<span class="fc" id="L882">    class TableNameFilter implements Filter&lt;String&gt; {</span>
		public boolean accept(String tableName) {
<span class="nc bnc" id="L884" title="All 6 branches missed.">			if (tableName.contains(&quot;$&quot;) || (excludeTables != null &amp;&amp; excludeTables.matcher(tableName).matches()))</span>
<span class="nc" id="L885">				return false;</span>
<span class="nc bnc" id="L886" title="All 4 branches missed.">		    return (includeTables == null || includeTables.matcher(tableName).matches());</span>

        }
    }
    
	private void importSequences() {
		try {
<span class="nc bnc" id="L893" title="All 2 branches missed.">			if (dialect.isSequenceSupported()) {</span>
<span class="nc" id="L894">				DBSequence[] sequences = dialect.querySequences(getConnection());</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">				for (DBSequence sequence : sequences) {</span>
<span class="nc" id="L896">					DBCatalog catalog = database.getCatalog(sequence.getCatalogName());</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">					if (catalog != null) {</span>
<span class="nc" id="L898">						DBSchema schema = catalog.getSchema(sequence.getSchemaName());</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">						if (schema != null)</span>
<span class="nc" id="L900">							schema.addSequence(sequence);</span>
					}
				}
			}
<span class="nc" id="L904">		} catch (Exception e) {</span>
<span class="nc" id="L905">			LOGGER.error(&quot;Error importing sequences&quot;, e);</span>
<span class="nc" id="L906">		}</span>
<span class="nc" id="L907">	}</span>

	private void importTriggers() throws SQLException {
<span class="nc bnc" id="L910" title="All 2 branches missed.">		for (DBCatalog catalog : database.getCatalogs())</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">			for (DBSchema schema : catalog.getSchemas())</span>
<span class="nc" id="L912">				importTriggers(schema);</span>
<span class="nc" id="L913">	}</span>

	private void importTriggers(DBSchema schema) throws SQLException {
<span class="nc" id="L916">		dialect.queryTriggers(schema, _connection);</span>
<span class="nc" id="L917">	}</span>

	private void importPackages() throws SQLException {
<span class="nc bnc" id="L920" title="All 2 branches missed.">		for (DBCatalog catalog : database.getCatalogs())</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">			for (DBSchema schema : catalog.getSchemas())</span>
<span class="nc" id="L922">				importPackages(schema);</span>
<span class="nc" id="L923">	}</span>

	private void importPackages(DBSchema schema) throws SQLException {
<span class="nc" id="L926">		dialect.queryPackages(schema, _connection);</span>
<span class="nc" id="L927">	}</span>


    
    // java.lang.Object overrides --------------------------------------------------------------------------------------

	@Override
	public String toString() {
<span class="fc" id="L935">	    return getClass().getSimpleName();</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201405220205</span></div></body></html>